<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Title</title>
</head>
<style>
@font-face {
font-family: GM;
font-weight: light, normal, bold, bolder;
src: url("https://corsproxy.io/?url=https://cdn.alimad.co/f/GeistMono.woff2")
format("woff2");
}
html,
body {
height: calc(var(--vh) * 100);
margin: 0;
padding: 0;
overflow: hidden;
background: #000;
color: #0f0;
font-family: GM, monospace;
}
* {
scrollbar-width: thin;
-webkit-tap-highlight-color: transparent;
scrollbar-color: #0f0 transparent;
user-select: none;
}
#app {
display: flex;
flex-direction: column;
height: calc(var(--vh) * 100);
padding: 6px;
gap: 6px;
}
#bar {
display: flex;
gap: 6px;
}
textarea,
button {
background: #000;
color: #0f0;
border: 1px solid #003300;
padding: 8px;
font: inherit;
border-radius: 0;
}
button:disabled{
color: darkgreen;
}
.msg-line {
position: relative;
padding-right: 24px;
}
.reply-btn {
opacity: 0;
position: absolute;
right: 2px;
top: 50%;
transform: translateY(-50%);
background: none;
border: none;
font-size: 14px;
color: #999;
cursor: pointer;
transition: opacity 0.2s, transform 0.2s;
}
.msg-line:hover .reply-btn {
opacity: 1;
transform: translateY(-50%) scale(1.1);
}
.reply-btn:hover {
color: #0f0;
transform: translateY(-50%) scale(1.3);
}
textarea {
flex: 1;
resize: none;
height: 42px;
outline: 0 solid #0000;
transition: outline 0.2s;
max-height: 50vh;
}
textarea:focus {
outline: 2px solid #0f0;
}
#feed {
flex: 1;
overflow: auto;
padding: 6px;
border: 1px solid #003300;
background: linear-gradient(#001000, #000);
font-size: 14px;
}
.msg {
padding: 4px 6px;
margin: 4px 0;
word-break: break-word;
max-width: 100%;
}
.me {
color: #0f0;
}
.other {
color: #6f6;
}
.meta {
font-size: 10px;
opacity: 0.6;
margin-bottom: 2px;
}
button {
cursor: pointer;
white-space: nowrap;
}
button:hover {
border-color: #0f0;
}
img.emoji {
width: 1.2em;
height: 1.2em;
vertical-align: text-bottom;
}
img.msgi {
width:80vw;
max-width: 400px;
display:block;
margin:4px 0;
border: #252 2px solid;
border-radius: 2px;
}
.msg.read {
font-size: small;
color: #0a0;
font-style: italic;
opacity: 0.7;
}
a {
color: #0f0;
text-decoration: underline;
text-decoration-color: #4f44;
cursor: pointer;
}
a:hover {
color: #4f4;
text-decoration: underline;
}
@media(max-width: 500px) {
.dek {
display: none;
}
}
.img-container {
position: relative;
display: inline-block;
}
.img-container .img-name {
position: absolute;
bottom: 6px;
right: 4px;
background: rgba(0,0,0,0.5);
backdrop-filter: blur(3px);
color: white;
font-size: 12px;
padding: 1px 3px;
border-radius: 2px;
pointer-events: none;
}
#otherUserDot{
width: 6px;
height: 6px;
border-radius: 50%;
transition: all 0.3s ease-in-out;
background-color: #444a;
display: inline-block;
vertical-align: middle;
margin-bottom: 2px;
margin-left: 4px;
}
.emoji-fallback {
display: inline-block;
background: #030;
border: transparent 1px solid;
color: #1e1;
padding: 0 2px;
border-radius: 2px;
font-size: 0.9em;
}
.emoji-fallback:hover{
border: #030 1px solid;
background: #010;
}
#otherUserDot.online{
background-color: #0f0;
transform: scale(1.1);
animation: ongoline 1s ease-in-out;
}
@keyframes ongoline {
0%{ transform: translate(0, 0) scale(1); background-color: #444a; }
10%{ transform: scale(0.2); background-color: #444a; }
30%{ transform: translate(-10px, 0); }
50%{ transform: scale(10); background-color: #444a; }
70%{ transform: translate(0, 0) scale(10); background-color: #0f0; }
80%{ transform: translate(0, 0) scale(8); background-color: #0f0; }
90%{ transform: scale(5); background-color: #0f0; }
100%{ transform: translate(0, 0) scale(1.1); background-color: #0f0; }
}
.tooltip {
position: relative;
display: inline-block;
cursor: pointer;
}
.tooltip::after {
content: attr(data-tip);
position: absolute;
bottom: 125%;
left: 50%;
transform: translateX(-10%) translateY(6px);
background: #1111;
backdrop-filter: blur(3px);
border: #333 1px solid;
color: #fff;
font-size: 10px;
padding: 4px 6px;
border-radius: 6px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: 
opacity 0.25s ease,
color 0.25s ease,
border 0.25s ease,
transform 0.25s cubic-bezier(0.22, 1, 0.36, 1);
box-shadow: 0 4px 12px #0003;
}
.msg-reply {
font-size: 13px;
color: #888;
border-left: 2px solid #0f0;
padding-left: 6px;
margin-bottom: 4px;
font-style: italic;
}
.tooltip:hover::after {
opacity: 1;
transform: translateX(-10%) translateY(-2px);
}
.tooltip.online:hover::after {
color: #0f0;
border: #0f03 1px solid;
}
.reply-selected {
background-color: #0f03;
border-radius: 4px;
transition: background-color 0.2s;
}
</style>
<div id="app">
<div id="bar">
<textarea id="txt" placeholder="> Enter..."></textarea>
<button id="send">Send</button>
</div>
<div style="color: #0f0; font-size: 12px; opacity: 1">
<span id="otherUserDot" class="tooltip" data-tip="Desynchronized"></span>
<span style="display: none;">Online: <a href="#" onclick="updateViewerCount()"><strong id="viewer-count">...</strong></a> • </a></span>
<a href="#" onclick="pull()"><span id="poller">Loading...</span></a>
<span class="dek">
<span> • <strong id="tiem">Parsing...</strong></span>
<span> • <span id="daet">Reading...</span></span>
</span>
<span> • <a id="upload" href="#" onclick="upload()" style="font-weight: bold;">Upload Image</a></span>
<span id="userstateo"> • <span id="userstate"></span></span>
<span class="dek" style="float: right"
>Channel: <strong id="channelname"></strong
></span>
</div>
<div id="feed"></div>
<input type="file" id="imgUpload" style="display:none" accept="image/*">
</div>
<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
<script>
const qp = new URLSearchParams(location.search);
let user = qp.get("channel"),
w,
mc = 0;
if (!user)
user =
prompt("channel (username)") ||
"guest" + Math.random().toString(36).slice(2);
window.addEventListener("beforeunload", () => {
offline();
disconnect();
const url = "https://live.alimad.co/leave?channel=" + encodeURIComponent("chat:" + user);
if (navigator.sendBeacon) {
navigator.sendBeacon(url);
} else {
const xhr = new XMLHttpRequest();
xhr.open("GET", url, false);
try { xhr.send(); } catch(e) { console.error(e) }
}
});
const g = (e) => { return document.getElementById(e); };
let mee = (ip) => { return (w.includes(ip))}
const uss = g("userstate");
const usso = g("userstateo");
user = user.trim();
g("channelname").textContent = user;
const feed = g("feed"),
txt = g("txt"),
send = g("send");
let currentReply = "";
let seen = new Set(),
polling = 15000;
let cp = false;
setInterval(() => {
const tiem = g("tiem");
const now = new Date();
tiem.textContent = now.toLocaleTimeString();
const daet = g("daet");
daet.textContent = now.toLocaleDateString();
}, 1000);
const safe = (s) =>
String(s).replace(
/[&<>]/g,
(ch) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[ch])
);
function emojiify(text) {
return text.replace(/:([0-9a-zA-Z-_]+):/g, (m, name) => {
const fixedName = name.replace(/^rofl$/i, "loll");
return `<img class="emoji" 
src="https://e.alimad.co/${fixedName}" 
onerror="this.outerHTML='<span class=&quot;emoji-fallback&quot;&gt;:${name}:&lt;/span&gt;'">`;
});
}
function updateScrollPercent() {
  const scrollTop = feed.scrollTop;
  const windowHeight = feed.clientHeight;
  const docHeight = feed.scrollHeight;
  const scrolledFromBottom = docHeight - windowHeight - scrollTop;
  const percent = ((scrolledFromBottom / (docHeight - windowHeight)) * 100).toFixed(1);
  console.log(percent);
  if(percent > 10){
  setState("Reading history "+Math.ceil(percent)+"%");}
}
setInterval(updateScrollPercent, 5000);
let crt;
function timeAgo(t) {
if (!t) return "";
const now = new Date();
const then = new Date(t);
if (isNaN(then)) return "";
const diffSec = Math.floor((now - then) / 1000);
if (diffSec < 10) return "just now";
if (diffSec < 60) return `${diffSec}s ago`;
const diffMin = Math.floor(diffSec / 60);
if (diffMin < 60) {
const sec = diffSec % 60;
return `${diffMin}m${sec ? `, ${sec}s` : ""} ago`;
}
const diffH = Math.floor(diffMin / 60);
if (diffH < 24) {
return `${diffH}h, ${diffMin % 60}m ago`;
}
const diffDays = Math.floor(diffH / 24);
const pad = (n) => n.toString().padStart(2, "0");
const weekday = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const yesterday = new Date(now);
yesterday.setDate(now.getDate() - 1);
if (then.getDate() === yesterday.getDate() &&
then.getMonth() === yesterday.getMonth() &&
then.getFullYear() === yesterday.getFullYear()) {
return `Yesterday ${pad(then.getHours())}:${pad(then.getMinutes())}`;
}
const diffDateDays = Math.floor((now - then) / (1000 * 60 * 60 * 24));
if (diffDateDays < 7) {
return `${weekday[then.getDay()]} ${pad(then.getHours())}:${pad(then.getMinutes())}`;
}
if (then.getFullYear() === now.getFullYear()) {
const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
return `${monthNames[then.getMonth()]} ${pad(then.getDate())} ${pad(then.getHours())}:${pad(then.getMinutes())}`;
}
const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
return `${monthNames[then.getMonth()]} ${pad(then.getDate())}, ${then.getFullYear()} ${pad(then.getHours())}:${pad(then.getMinutes())}`;
}
let currentReplyLine = null;
function render(it, neww) {
let replyToText = it?.status;
if (replyToText?.startsWith("reply:")) {
replyToText = replyToText.replace("reply:", "");
} else { replyToText = ""; }
let body = "", time = "", ip = "", isRead = false, me = false;
if (it && typeof it === "object") {
body = it.text ?? JSON.stringify(it);
ip = it.ip ?? "";
me = mee(ip);
time = it.time ?? "";
isRead = it.status === "read";
if (isRead && me) return;
} else body = String(it);
const id = body + time + ip;
if (seen.has(id)) return;
seen.add(id);
const msg = document.createElement("div");
msg.className = isRead ? "msg read" : "msg " + (me ? "me" : "other");
if (isRead) {
msg.textContent = "-- Read " + timeAgo(time) + " --";
feed.appendChild(msg);
return;
}
const meta = document.createElement("span");
meta.className = "meta";
meta.dataset.time = time;
meta.dataset.user = me ? "you" : "";
meta.dataset.ip = ip;
msg.appendChild(meta);
if (replyToText) {
const replyDiv = document.createElement("div");
replyDiv.className = "msg-reply";
let r = replyToText;
r = r.replace(/<https?:\/\/\S+>/gi, urlWithBrackets => {
const url = urlWithBrackets.slice(1, -1);
const parts = url.split("/").filter(Boolean);
let filename = parts[parts.length - 1];
return `<a href="${url}" target="_blank">${filename}</a>`;
});
replyDiv.innerHTML = "↪ "+r;
msg.appendChild(replyDiv);
}
const lines = body.split("\n");
lines.forEach(lineText => {
const line = document.createElement("div");
line.className = "msg-line";
let isActiveReply = lineText == currentReply && time == crt;
let formatted = safe(lineText)
.replace(/&lt;(https?:\/\/\S+)&gt;/gi, (_, url) => {
const parts = url.split("/").filter(Boolean);
const filename = parts[parts.length - 1];
return `<br>
<div class="img-container">
<img class="msgi" src="${url}">
<div class="img-name">${filename}</div>
</div><br>
`;
});
if (formatted === safe(lineText)) {
formatted = safe(lineText).replace(/(https?:\/\/\S+)/gi, url => `<a href="${url}" target="_blank">${url}</a>`);
}
line.innerHTML = emojiify(formatted);
const replyBtn = document.createElement("button");
replyBtn.className = "reply-btn";
replyBtn.innerHTML = "↩";
replyBtn.title = "Reply";
replyBtn.onclick = e => {
e.stopPropagation();
startReply(replyToText ? "Reply: "+lineText : lineText, ip, time);
setReplyHighlight(line);
};
if(isActiveReply) setReplyHighlight(line);
if(lineText.trim().length > 0){
line.appendChild(replyBtn);}
line.addEventListener("click", () => {
if (!isTouch) return;
document.querySelectorAll(".reply-btn").forEach(btn => btn.style.opacity = 0);
replyBtn.style.opacity = 1;
});
line.addEventListener("contextmenu", (e)=>{
e.preventDefault();
startReply(replyToText ? "Reply: "+lineText : lineText, ip, time);
setReplyHighlight(line);
})
msg.appendChild(line);
});
feed.appendChild(msg);
updateOne(meta);
if (neww) {
setTimeout(() => feed.scrollTo({ top: feed.scrollHeight, behavior: "smooth" }), 100);
}
}
function setReplyHighlight(line) {
if (currentReplyLine) currentReplyLine.classList.remove("reply-selected");
currentReplyLine = line;
line.classList.add("reply-selected");
}
function clearReplyHighlights() {
if (currentReplyLine) {
currentReplyLine.classList.remove("reply-selected");
currentReplyLine = null;
}
}
function startReply(body, ip, time){
currentReply = body;
crt = time;
}
function updateOne(el) {
const u = el.dataset.user || "";
const ip = el.dataset.ip || "";
const ta = timeAgo(el.dataset.time);
const bits = [];
if (u) bits.push(safe(u));
if (ip) bits.push(safe(ip));
if (ta) bits.push(ta);
el.innerHTML = "[" + bits.join(" • ") + "]";
}
function updateAll() {
document.querySelectorAll(".meta").forEach(updateOne);
}
async function pull() {
if (cp) return;
cp = true;
g("poller").textContent = "Refreshing...";
try {
const r = await fetch(
"https://log.alimad.co/api/pull?pwd=PASSWORDISBANANA&channel=" +
encodeURIComponent("chat:" + user),
{ cache: "no-store" }
);
if (!r.ok) return;
const j = await r.json();
let logs = j.logs ?? j.data ?? j;
if (!Array.isArray(logs)) logs = Object.values(logs);
if (!logs.length) return;
let merged = [];
let prev = logs[0];
for (let k = 1; k < logs.length; k++) {
const cur = logs[k];
const sameIP = prev.ip === cur.ip;
const sameStatus = prev.status === cur.status;
const closeTime =
Math.abs(new Date(prev.time) - new Date(cur.time)) < 300000;
if (sameIP && sameStatus && closeTime) {
prev.text += "\n" + cur.text;
} else {
merged.push(prev);
prev = cur;
}
}
merged.push(prev);
feed.innerHTML = "";
seen.clear();
for(let i = 0; i < merged.length; i++){
render(merged[i], mc < logs.filter((l) => l.status != "read").length);
}
if (mc < logs.filter((l) => l.status != "read").length && !mee(logs[logs.length - 1].ip && logs[logs.length - 1].status != "read")){
read();
}
mc = logs.filter((l) => l.status != "read").length;
cp = false;
g("poller").textContent = "Refreshed";
} catch (e) {
console.error(e);
cp = false;
g("poller").textContent = "Refresh failed";
}
}
async function read() {
if (localStorage.getItem("chat:" + user + ":lastRead")) {
const lastRead = parseInt(
localStorage.getItem("chat:" + user + ":lastRead")
);
if (Date.now() - lastRead < 60000) {
return;
}
}
await fetch(
"https://log.alimad.co/api/log?channel=" +
encodeURIComponent("chat:" + user) +
"&text=read&status=read"
);
localStorage.setItem("chat:" + user + ":lastRead", Date.now().toString());
}
document.addEventListener("click", ()=>{document.title = "Title"})
async function sendMsg(text) {
if (!text.trim()) return;
txt.disabled = true;
send.disabled = true;
try {
await fetch(
"https://log.alimad.co/api/log?" +
new URLSearchParams({
channel: "chat:" + user,
text: text,
...(currentReply && { status: "reply:" + currentReply })
})
);
statesend();
currentReply = "";
txt.value = "";
txt.disabled = false;
send.disabled = false;
pull();
} catch {}
}
let isTouch = false;
window.addEventListener('touchstart', function onFirstTouch() {
isTouch = true;
window.removeEventListener('touchstart', onFirstTouch, false);
}, false);
send.onclick = () => sendMsg(txt.value);
txt.addEventListener("keydown", (e) => {
if (e.key === "Enter" && !(e.shiftKey || isTouch)) {
e.preventDefault();
sendMsg(txt.value);
}
});
function initiate() {
pull();
updateViewerCount();
setInterval(pull, polling);
setInterval(updateAll, 1000);
setInterval(updateViewerCount, 5000);
}
let uv = false;
async function updateViewerCount() {
if(uv) return;
uv = true;
try {
g("viewer-count").style.color = "#9f9";
const r = await fetch(
"https://live.alimad.co/ping?app=" + encodeURIComponent("chat:" + user)
);
if (!r.ok) return;
const j = await r.text();
const count = parseInt(j) || 0;
g("viewer-count").textContent = count;
g("viewer-count").style.color = "#0f0";
} catch (e) {}
uv = false;
}
document.addEventListener("DOMContentLoaded", async () => {
w = localStorage.getItem("myip");
w = JSON.parse(w || "[]");
fetch("https://api.ipify.org")
.then((r) => r.text())
.then((data) => {
if (!w.includes(data)) w.push(data);
localStorage.setItem("myip", JSON.stringify(w));
initiate();
connect(user);
});
});
const tt = g("txt");
const scaleI = () => {
tt.style.height = "42px";
tt.style.height = (tt.scrollHeight + 2) + "px";
}
tt.addEventListener("input", scaleI);
tt.addEventListener("input", typing);
setInterval(scaleI, 500);
let currentProgress = 0;
let displayedProgress = 0.01;
let animFrameId = null;
async function upload(fromPaste = false, pasteFile = null) {
const fileInput = document.getElementById("imgUpload");
const uploadBtn = g("upload");
const up = async () => {
const file = fileInput.files[0];
if (!file) return;
uploadBtn.textContent = "Uploading...";
const form = new FormData();
form.append("image", file);
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://api.imgbb.com/1/upload?key=0035f29ef2ddb2862584cd5114e4a7ee");
xhr.upload.onprogress = e => {
if (e.lengthComputable) currentProgress = e.loaded / e.total;
};
xhr.onload = () => {
if (xhr.status === 200) {
const data = JSON.parse(xhr.responseText);
if (data.success) {
const url = data.data.url;
txt.value += `<${url}>`;
}
} else {
alert("Upload failed: " + xhr.statusText);
}
currentProgress = 1;
setTimeout(() => {
uploadBtn.textContent = "Upload Image";
currentProgress = 0;
displayedProgress = 0;
if (animFrameId) cancelAnimationFrame(animFrameId);
animFrameId = null;
}, 500);
};
xhr.onerror = () => {
uploadBtn.textContent = "Upload Failed";
alert("Upload failed");
currentProgress = 0;
displayedProgress = 0;
if (animFrameId) cancelAnimationFrame(animFrameId);
animFrameId = null;
};
xhr.send(form);
animateProgress();
};
if (!fromPaste) fileInput.click();
else if (pasteFile) {
const dt = new DataTransfer();
dt.items.add(pasteFile);
fileInput.files = dt.files;
up();
}
fileInput.onchange = up;
function animateProgress() {
displayedProgress += (currentProgress - displayedProgress) * 0.1;
const percent = Math.floor(displayedProgress * 100);
if (currentProgress > 0 || displayedProgress > 0) {
uploadBtn.textContent = `${percent}% Uploading...`;
animFrameId = requestAnimationFrame(animateProgress);
} else {
if (animFrameId) cancelAnimationFrame(animFrameId);
animFrameId = null;
}
}
}
txt.addEventListener("paste", async (e) => {
const items = e.clipboardData?.items;
if (!items) return;
for (const item of items) {
if (item.type.startsWith("image/")) {
e.preventDefault();
const blob = item.getAsFile();
if (!blob) return;
await upload(true, blob);
}
}
});
window.OneSignalDeferred = window.OneSignalDeferred || [];
OneSignalDeferred.push(async function(OneSignal) {
await OneSignal.init({
appId: "b885061e-346e-4289-b31f-f082b0704cbb",
safari_web_id: "web.onesignal.auto.67fef31a-7360-4fd8-9645-1463ac233cef",
notifyButton: {
enable: true,
},
});
});
function toTitleCase(str) {
return str
.toLowerCase()
.split(' ')
.map(word => word.charAt(0).toUpperCase() + word.slice(1))
.join(' ');
}
const WS_URL = 'wss://ws.alimad.co';
let ws = null;
let currentChannel = null;
let listeners = [];
let lastState = null;
let lastStateTime = 0;
let stateTimeout = null;
let typingTimeout = null;
let otherUsers = new Map();
let uonline = false;
let offlineTimeouts = new Map();
function ssend(obj) {
if (!ws || ws.readyState !== 1) return;
ws.send(JSON.stringify(obj));
}
function st(g) {
uss.textContent = g;
usso.style.display = g ? "inline" : "none";
}
function setOtherUserStatus(isOnline) {
const dot = document.getElementById('otherUserDot');
dot.dataset.tip = isOnline ? 'Synchronized' : 'Desynchronized';
if(isOnline) dot.classList.add("online")
else dot.classList.remove("online")
}
function parseState(ip, state) {
if (state == "send") { pull(); st(''); 
if(document.title == "Idle" || document.title == "Typing"){
document.title = "New Message";alert("New message!!!")} return };
if (["idle", "indeterminate"].includes(state)) {
if(document.title == "Typing") document.title = "Idle";
st("");
return;
}
if (state === 'online') {
if(!uonline) {
if(document.title == "Idle"){
document.title = "ONLINE!";
alert("Online!");
setTimeout(()=>{document.title = "Idle"}, 5000)
}
}
uonline = true;
setOtherUserStatus(true);
return;
}
if (state === 'active') {
st("");
return;
}
if (state === 'outside') {
st('In another tab');
return;
}
if (state === 'offline') {
st('');
uonline = false;
setOtherUserStatus(false);
return;
}
if (state == 'typing'){ state = 'typing...'; if(document.title == "Idle") document.title = "Typing";}
st(toTitleCase(state));
}
function connect(channel) {
st("Connecting...");
if (ws && ws.readyState === 1) return;
currentChannel = channel;
ws = new WebSocket(WS_URL);
ws.onopen = () => {
ssend({ type: 'connect', channel });
st("");
setInterval(() => online(), 5000);
};
ws.onmessage = e => {
let msg;
try { msg = JSON.parse(e.data); } catch { msg = e.data; }
if (msg?.from && !mee(msg.from) && msg?.data?.state) {
const ip = msg.from;
const state = msg.data.state;
parseState(ip, state);
if (otherUsers.has(ip)) clearTimeout(otherUsers.get(ip));
otherUsers.set(ip, setTimeout(() => {
parseState(ip, 'indeterminate');
otherUsers.delete(ip);
}, 5000));
if (offlineTimeouts.has(ip)) clearTimeout(offlineTimeouts.get(ip));
offlineTimeouts.set(ip, setTimeout(() => {
parseState(ip, 'offline');
offlineTimeouts.delete(ip);
}, 15000));
}
listeners.forEach(cb => cb(msg));
};
ws.onclose = () => {
ws = null;
st("Reconnecting...");
setTimeout(() => connect(currentChannel), 1000);
};
}
function disconnect() {
if (ws) ws.onclose = () => {};
if (ws) ws.close();
ws = null;
st("");
}
function setState(state) {
if (!ws || ws.readyState !== 1 || !currentChannel) return;
const now = Date.now();
if (state === lastState && now - lastStateTime < 2500) return;
ssend({ type: 'broadcast', channel: currentChannel, data: { state } });
lastState = state;
lastStateTime = now;
clearTimeout(stateTimeout);
if (!["online", "typing", "send"].includes(state)) {
stateTimeout = setTimeout(() => {
ssend({ type: 'broadcast', channel: currentChannel, data: { state: 'idle' } });
lastState = 'idle';
lastStateTime = Date.now();
}, 3000);
}
}
function typing() {
setState('typing');
clearTimeout(typingTimeout);
typingTimeout = setTimeout(() => {
setState('idle');
}, 2000);
}
function online() { setState('online'); }
function offline() { setState('offline'); }
function outside() { setState('outside'); }
function idling() { setState('idle'); }
function active() { setState('active'); }
function statesend() { setState('send'); }
function listen(cb) {
listeners.push(cb);
}
document.addEventListener('visibilitychange', () => {
if (document.visibilityState === 'hidden') {outside();document.title = "Idle"}
else if (document.visibilityState === 'visible') {active();document.title = "Title"}
});
function updateVH() {
document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');
}
updateVH();
window.addEventListener('resize', updateVH);
</script>
