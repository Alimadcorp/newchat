<style>
  @font-face {
    font-family: GM;
    src: url("https://corsproxy.io/?url=https://cdn.alimad.co/f/GeistMono.woff2")
      format("woff2");
  }
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    color: #0f0;
    font-family: GM, monospace;
  }
  * {
    scrollbar-width: thin;
    scrollbar-color: #0f0 transparent;
  }
  #app {
    display: flex;
    flex-direction: column;
    height: 100vh;
    padding: 6px;
    gap: 6px;
  }
  #bar {
    display: flex;
    gap: 6px;
  }
  #feed {
    flex: 1;
    overflow: auto;
    padding: 6px;
    border: 1px solid #003300;
    background: linear-gradient(#001000, #000);
    font-size: 14px;
  }
  .msg {
    padding: 4px 6px;
    margin: 4px 0;
    word-break: break-word;
    max-width: 90%;
  }
  .me {
    color: #0f0;
  }
  .other {
    color: #6f6;
  }
  .meta {
    font-size: 10px;
    opacity: 0.6;
    margin-bottom: 2px;
  }
  textarea,
  button {
    background: #000;
    color: #0f0;
    border: 1px solid #003300;
    padding: 8px;
    font: inherit;
    border-radius: 0;
  }
  textarea {
    flex: 1;
    resize: none;
    height: 42px;
  }
  button {
    cursor: pointer;
    white-space: nowrap;
  }
  button:hover {
    border-color: #0f0;
  }
  img.emoji {
    width: 1em;
    height: 1em;
    vertical-align: text-bottom;
  }
  .msg.read {
    font-size: small;
    color: #0a0;
    font-style: italic;
    opacity: 0.7;
  }
</style>
<div id="app">
  <div id="bar">
    <textarea id="txt" placeholder="> enter…"></textarea>
    <button id="send">send</button>
  </div>
  <div id="viewer-count" style="color: #0f0; font-size: 12px; opacity: 0.6">
    Online: …
  </div>
  <div id="feed"></div>
</div>
<script>
  const qp = new URLSearchParams(location.search);
  let user = qp.get("channel"),
    w,
    mc = 0,
    lastRendered = 0;
  if (!user)
    user =
      prompt("channel (username)") ||
      "guest" + Math.random().toString(36).slice(2);
  user = user.trim();
  const feed = document.getElementById("feed"),
    txt = document.getElementById("txt"),
    send = document.getElementById("send");
  let seen = new Set(),
    polling = 10000;
  const safe = (s) =>
    String(s).replace(
      /[&<>]/g,
      (ch) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[ch])
    );
  function emojiify(text) {
    return text.replace(
      /:([0-9a-zA-Z-_]+):/g,
      (m, name) =>
        `<img class="emoji" src="https://e.alimad.co/${name.replace(
          /^rofl$/i,
          "loll"
        )}">`
    );
  }
  function timeAgo(t) {
    if (!t) return "";
    let s = (Date.now() - new Date(t).getTime()) / 1000;
    if (isNaN(s)) return "";
    if (s < 10) return "just now";
    if (s < 60) return Math.floor(s) + "s ago";
    s /= 60;
    if (s < 60) return Math.floor(s) + "m ago";
    s /= 60;
    if (s < 24) return Math.floor(s) + "h ago";
    return Math.floor(s / 24) + "d ago";
  }
  function render(it) {
    let body = "",
      time = "",
      ip = "",
      isRead = false,
      me = false;
    if (it && typeof it === "object") {
      body = it.text ?? JSON.stringify(it);
      ip = it.ip ?? "";
      me = w.includes(ip);
      time = it.time ?? "";
      isRead = it.status === "read";
      if (isRead && me) return;
    } else body = String(it);
    const id = body + time + ip;
    if (seen.has(id)) return;
    seen.add(id);
    const msg = document.createElement("div");
    if (isRead) {
      msg.className = "msg read";
      msg.textContent = "-- Read " + timeAgo(time) + " --";
      feed.appendChild(msg);
      feed.scrollTop = feed.scrollHeight;
      return;
    }
    msg.className = "msg " + (me ? "me" : "other");
    const meta = document.createElement("span");
    meta.className = "meta";
    meta.dataset.time = time;
    meta.dataset.user = me ? "you" : "";
    meta.dataset.ip = ip;
    msg.appendChild(meta);
    msg.insertAdjacentHTML(
      "beforeend",
      "<br>" + emojiify(safe(body)).replace(/\n/g, "<br>")
    );
    feed.appendChild(msg);
    updateOne(meta);
    feed.scrollTop = feed.scrollHeight;
  }
  function updateOne(el) {
    const u = el.dataset.user || "";
    const ip = el.dataset.ip || "";
    const ta = timeAgo(el.dataset.time);
    const bits = [];
    if (u) bits.push(safe(u));
    if (ip) bits.push(safe(ip));
    if (ta) bits.push(ta);
    el.innerHTML = "[" + bits.join(" • ") + "]";
  }
  function updateAll() {
    document.querySelectorAll(".meta").forEach(updateOne);
  }
  async function pull() {
    try {
      const r = await fetch(
        "https://log.alimad.co/api/pull?pwd=PASSWORDISBANANA&channel=" +
          encodeURIComponent("chat:" + user),
        { cache: "no-store" }
      );
      if (!r.ok) return;
      const j = await r.json();
      let logs = j.logs ?? j.data ?? j;
      if (!Array.isArray(logs)) logs = Object.values(logs);
      if (!logs.length) return;
      let merged = [];
      let prev = logs[0];
      for (let k = 1; k < logs.length; k++) {
        const cur = logs[k];
        const sameIP = prev.ip === cur.ip;
        const sameStatus = prev.status === cur.status;
        const closeTime =
          Math.abs(new Date(prev.time) - new Date(cur.time)) < 300000;
        if (sameIP && sameStatus && closeTime) {
          prev.text += "\n" + cur.text;
        } else {
          merged.push(prev);
          prev = cur;
        }
      }
      merged.push(prev);
      feed.innerHTML = "";
      seen.clear();
      merged.forEach(render);
      if (
        mc < logs.filter((l) => l.status != "read").length &&
        !w.includes(
          logs[logs.length - 1].ip && logs[logs.length - 1].status != "read"
        )
      )
        read();
      mc = logs.filter((l) => l.status != "read").length;
    } catch {}
  }
  async function read() {
    if (localStorage.getItem("chat:" + user + ":lastRead")) {
      const lastRead = parseInt(
        localStorage.getItem("chat:" + user + ":lastRead")
      );
      if (Date.now() - lastRead < 60000) {
        return;
      }
    }
    await fetch(
      "https://log.alimad.co/api/log?channel=" +
        encodeURIComponent("chat:" + user) +
        "&text=read&status=read"
    );
    localStorage.setItem("chat:" + user + ":lastRead", Date.now().toString());
  }
  async function sendMsg(text) {
    if (!text.trim()) return;
    try {
      await fetch(
        "https://log.alimad.co/api/log?channel=" +
          encodeURIComponent("chat:" + user) +
          "&text=" +
          encodeURIComponent(text)
      );
      txt.value = "";
      pull();
    } catch {}
  }
  send.onclick = () => sendMsg(txt.value);
  txt.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMsg(txt.value);
    }
  });
  function initiate() {
    pull();
    updateViewerCount();
    setInterval(pull, polling);
    setInterval(updateAll, 5000);
    setInterval(updateViewerCount, 5000);
  }
  async function updateViewerCount() {
    try {
      const r = await fetch(
        "https://live.alimad.co/ping?app=" + encodeURIComponent("chat:" + user)
      );
      if (!r.ok) return;
      const j = await r.text();
      const count = parseInt(j) || 0;
      document.getElementById("viewer-count").textContent = "Online: " + count;
    } catch (e) {}
  }
  document.addEventListener("DOMContentLoaded", async () => {
    w = localStorage.getItem("myip");
    w = JSON.parse(w || "[]");
    fetch("https://api.ipify.org")
      .then((r) => r.text())
      .then((data) => {
        if (!w.includes(data)) w.push(data);
        localStorage.setItem("myip", JSON.stringify(w));
        initiate();
      });
  });
</script>
